---
layout: post
title: "前端知识体系回顾——第二章 HTTP协议 3"
date: 2016-05-07 00:46:05
author: "陈凯"
meta: "技术基础"
description: "摘要：「前端知识体系系列第二部分，这部分内容较多，分成三篇进行讲述,本文是，第二章HTTP系列第三篇。」"
categories: 前端笔记 技术基础
excerpt: 开发基础
---

* content
{:toc}

----

## 21.说说网络分层里七层模型是哪七层

+ 应用层：应用层、表示层、会话层（从上往下）（`HTTP、FTP、SMTP、DNS`）
+ 传输层（`TCP`和`UDP`）
+ 网络层（`IP`）
+ 数据链路层（以太网）
+ 物理层

**每一层的作用如下：**

+ 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
+ 数据链路层：将比特组装成帧和点到点的传递（帧Frame）
+ 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
+ 传输层：提供端到端的可靠报文传递和错误恢复（流Segment）
+ 会话层：建立、管理和终止会话（会话协议数据单元SPDU）
+ 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
+ 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

## 22.TCP/IP分层模型

**TCP/IP分层模型**（TCP/IP Layening Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)。

**TCP/IP协议**被组织成**四个概念层**，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。

**第一层:网络接口层**

包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。
　　
**第二层:网络层（Internet Layer）。**

**网络层解决的是计算机到计算机间的通信问题，它包括三个方面的功能：**

+ 处理来自传输层的分组发送请求，收到请求后将分组装入IP数据报，填充报头，选择路径，然后将数据报发往适当的网络接口。
+ 处理数据报。
+ 处理网络控制报文协议、即处理路径、流量控制、阻塞等。
+ 对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。

**第三层:传输层**

传输层解决的是计算机程序到计算机程序之间的通信问题。对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。

**第四层:应用层**

对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。

## 23.各种应用层的协议

+ ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
+ TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
+ HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
+ DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。

## 24.常见web安全及防护原理

**sql注入原理**

就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**总的来说有以下几点：**

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2. 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。
3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4. 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

**XSS原理及防范**

**Xss**(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 `html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，
当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

**XSS防范方法**

首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以`encode`，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的`XSS` 攻击。
首先，避免直接在`cookie` 中泄露用户隐私，例如email、密码等等。
其次，通过使`cookie` 和系统`ip` 绑定来降低`cookie` 泄露后的危险。这样攻击者得到的`cookie` 没有实际价值，不可能拿来重放。
尽量采用`POST` 而非`GET` 提交表单

**XSS与CSRF有什么区别吗？**

XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

要完成一次`CSRF`攻击，受害者必须依次完成两个步骤：

登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。

**CSRF的防御**

服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。通过验证码的方法

## 25.什么是Etag？

当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。

情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到  `200 OK`(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。

情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和`Etag`

然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据`Etag`，判断文件内容自上一次请求之后，有没有发生变化

情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发`index.html`的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— `304 Not Modified`，此时浏览器就会从本地缓存中获取`index.html`的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。
情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①

① 只有get请求会被缓存，post请求不会

Expires和Cache-Control

`Expires`要求客户端和服务端的时钟严格同步。`HTTP1.1`引入`Cache-Control`来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。

Cache-Control: no-cache, private, max-age=0
ETag: abcde
Expires: Thu, 15 Apr 2014 20:00:00 GMT
Pragma: private
Last-Modified: $now // RFC1123 format

ETag应用:

`Etag`由服务器端生成，客户端通过`If-Match`或者说`If-None-Match`这个条件判断请求来验证资源是否修改。常见的是使用`If-None-Match`。请求一个文件的流程可能如下：

**====第一次请求===**

1. 客户端发起 HTTP GET 请求一个文件；

2. 服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200

**====第二次请求===**

客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办

答案是同时使用，也就是说在完全匹配`If-Modified-Since`和`If-None-Match`即检查完修改时间和`Etag`之后，

服务器才能返回304.(不要陷入到底使用谁的问题怪圈)

**为什么使用Etag请求头?**

Etag 主要为了解决 `Last-Modified` 无法解决的一些问题。


----------


## 26.请你谈谈Cookie的弊端

Cookie 虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。

**第一：每个特定的域名下最多生成20个`cookie`**

1. IE6或更低版本最多20个cookie

2. IE7和之后的版本最后可以有50个cookie。

3. Firefox最多50个cookie

4. chrome和Safari没有做硬性限制

`IE`和`Opera` 会清理近期最少使用的`cookie`，`Firefox`会随机清理`cookie`。

`cookie`的最大大约为`4096`字节，为了兼容性，一般不能超过`4095`字节。

IE 提供了一种存储可以持久化用户数据，叫做`userdata`，从`IE5.0`就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。

**优点：极高的扩展性和可用性**

1. 通过良好的编程，控制保存在cookie中的session对象的大小。

2. 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。

3. 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。

4. 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。

**缺点：**

1. `Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.

2. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
    


----------


## 27.浏览器本地存储

+ 在较高版本的浏览器中，`js`提供了`sessionStorage`和`globalStorage`。在`HTML5`中提供了`localStorage`来取代`globalStorage`。

+ `html5`中的`Web Storage`包括了两种存储方式：`sessionStorage`和`localStorage`。

+ `sessionStorage`用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此`sessionStorage`不是一种持久化的本地存储，仅仅是会话级别的存储。

+ 而`localStorage`用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

## 28.web storage和cookie的区别

+ `Web Storage`的概念和`cookie`相似，区别是它是为了更大容量存储设计的。`Cookie`的大小是受限的，并且每次你请求一个新的页面的时候`Cookie`都会被发送过去，这样无形中浪费了带宽，另外`cookie`还需要指定作用域，不可以跨域调用。

+ 除此之外，`Web Storage`拥有`setItem,getItem,removeItem,clear`等方法，不像`cookie`需要前端开发者自己封装`setCookie，getCookie`。

+ 但是`cookie`也是不可以或缺的：`cookie`的作用是与服务器进行交互，作为`HTTP`规范的一部分而存在 ，而`Web Storage`仅仅是为了在本地“存储”数据而生

+ 浏览器的支持除了`IE７`及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的`userData`其实就是`javascript`本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持`web storage`。

+ `localStorage`和`sessionStorage`都具有相同的操作方法，例如`setItem、getItem`和`removeItem`等。

## 29.cookie 和session 的区别：

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5. 所以个人建议：
将登陆信息等重要信息存放为SESSION;
其他信息如果需要保留，可以放在COOKIE中.

## 30.IE缓存问题

在IE浏览器下，如果请求的方法是`GET`，并且请求的`URL`不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的`URL`，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(`'t'= + new Date().getTime()`) 或者：

```
open('GET','demo.php?rand=+Math.random()',true);//
```

## 31.如何删除一个cookie

1. 将时间设为当前时间往前一点。

```
var date = new Date();
date.setDate(date.getDate() 1);//真正的删除
`setDate() `方法用于设置一个月的某一天。
```

2. expires的设置

```
document.cookie = 'user='+ encodeURIComponent('name')  + ';expires = ' + new Date(0)
```

## 32.说说mongoDB和MySQL的区别

`MySQL`是传统的关系型数据库，`MongoDB`则是非关系型数据库
 `mongodb`以`BSON`结构（二进制）进行存储，对海量数据存储有着很明显的优势。
 
## 33.讲讲304缓存的原理

+ 服务器首先产生`ETag`，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。

+ 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

+ 客户端请求一个页面（A）。 服务器返回页面A，并在给`A`加上一个`ETag`。 客户端展现该页面，并将页面连同`ETag`一起缓存。 客户再次请求页面`A`，并将上次请求时服务器返回的`ETag`一起传递给服务器。 服务器检查该`ETag`，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应`304`（未修改——`Not Modified`）和一个空的响应体。

